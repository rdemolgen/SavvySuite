import htsjdk.variant.variantcontext.*;
import htsjdk.variant.variantcontext.writer.*;
import htsjdk.variant.vcf.*;
import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Reads a VCF file and data on contamination, and outputs a new VCF file with the variants corrected for the contamination.
 * The genotype (GT) and probability (PL) entries are updated for every sample with contamination data.
 * The contamination data should be generated by SavvyContaminationFinder.
 *
 * @author Matthew Wakeling
 */
public class SavvyContaminationRepairer
{
	public static final Pattern TAB = Pattern.compile("\t");

	public static void main(String[] args) throws Exception {
		String vcfFile = args[0];
		String outputFile = (args.length == 2 ? args[1] : null);
		if (args.length > 2) {
			System.err.println("Usage: java SavvyContaminationRepairer input.vcf [output.vcf] <contam_data");
			System.exit(1);
		}
		VCFFileReader reader = new VCFFileReader(new File(vcfFile));
		List<String> sampleNames = reader.getFileHeader().getGenotypeSamples();
		int sampleCount = sampleNames.size();
		HashMap<String, Integer> sampleNumbers = new HashMap<String, Integer>();
		double[][] contributions = new double[sampleCount][];
		for (int sampleNo = 0; sampleNo < sampleCount; sampleNo++) {
			contributions[sampleNo] = new double[sampleCount];
			sampleNumbers.put(sampleNames.get(sampleNo), sampleNo);
		}
		HashSet<String> samplesToCorrect = new HashSet<String>();
		{
			BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
			String line = in.readLine();
			while (line != null) {
				String[] split = TAB.split(line);
				if (split.length == 3) {
					if (sampleNumbers.containsKey(split[0]) && sampleNumbers.containsKey(split[1])) {
						samplesToCorrect.add(split[0]);
						int sample1 = sampleNumbers.get(split[0]);
						int sample2 = sampleNumbers.get(split[1]);
						contributions[sample1][sample2] = Double.parseDouble(split[2]);
					}
				}
				line = in.readLine();
			}
			in.close();
		}
		for (int sampleNo = 0; sampleNo < sampleCount; sampleNo++) {
			double total = 0.0;
			for (int i = 0; i < sampleCount; i++) {
				if (i != sampleNo) {
					total += contributions[sampleNo][i];
				}
			}
			contributions[sampleNo][sampleNo] = 1.0 - total;
		}
		// Now contributions contains the contamination data for these samples.
		VariantContextWriterBuilder writerBuilder = new VariantContextWriterBuilder();
		if (outputFile != null) {
			writerBuilder.setOutputFile(outputFile);
		} else {
			writerBuilder.setOutputVCFStream(System.out);
		}
		writerBuilder.setReferenceDictionary(reader.getFileHeader().getSequenceDictionary());
		VariantContextWriter writer = writerBuilder.build();
		VCFHeader header = reader.getFileHeader();
		header.addMetaDataLine(new VCFFormatHeaderLine("OLDGT", 1, VCFHeaderLineType.String, "The original genotype before correcting for contamination"));
		header.addMetaDataLine(new VCFFormatHeaderLine("OLDPL", VCFHeaderLineCount.G, VCFHeaderLineType.Integer, "The original PL scores before correcting for contamination"));
		writer.writeHeader(header);
		for (VariantContext context : reader) {
			boolean biallelic = true;
			if ((!"X".equals(context.getChr())) && (!"Y".equals(context.getChr())) && (!context.getChr().startsWith("G"))) {
				if (context.getAlleles().size() > 2) {
					biallelic = false;
				}
			} else {
				biallelic = false;
			}
			if (biallelic) {
				// Adjust the variants according to the contamination.
				int[] genotypes = new int[sampleCount];
				int[] refs = new int[sampleCount];
				int[] alts = new int[sampleCount];
				for (int i = 0; i < sampleCount; i++) {
					Genotype g2 = context.getGenotype(sampleNames.get(i));
					int[] ad2 = g2.getAD();
					if (ad2 == null) {
						ad2 = new int[2];
						ad2[0] = 30;
						ad2[1] = 0;
					}
					double frac2 = (1.0 * ad2[1]) / (ad2[0] + ad2[1]);
					genotypes[i] = frac2 < 0.15 ? 0 : (frac2 < 0.85 ? 1 : 2);
					refs[i] = ad2[0];
					alts[i] = ad2[1];
				}
				SavvyContaminationFinder.Variant v = new SavvyContaminationFinder.Variant(genotypes, refs, alts);
				HashSet<String> seenArrangements = new HashSet<String>();
				String arrangement = "";
				for (int sampleNo = 0; sampleNo < sampleCount; sampleNo++) {
					arrangement = arrangement + v.getGenotypes()[sampleNo];
				}
				//System.err.println("Variant at " + context.getContig() + ":" + context.getStart());
				while (!seenArrangements.contains(arrangement)) {
					//System.err.println(arrangement);
					seenArrangements.add(arrangement);
					arrangement = "";
					for (int sampleNo = 0; sampleNo < sampleCount; sampleNo++) {
						v.adjustGenotype(sampleNo, contributions[sampleNo], true);
						arrangement = arrangement + v.getGenotypes()[sampleNo];
					}
				}
				VariantContextBuilder builder = new VariantContextBuilder(context);
				List<Allele> alleles = context.getAlleles();
				List<Genotype> newGenotypes = new ArrayList<Genotype>();
				for (int sampleNo = 0; sampleNo < sampleCount; sampleNo++) {
					String sampleName = sampleNames.get(sampleNo);
					Genotype oldGenotype = context.getGenotype(sampleName);
					if (samplesToCorrect.contains(sampleName)) {
						GenotypeBuilder gBuilder = new GenotypeBuilder(oldGenotype);
						gBuilder.attribute("OLDGT", oldGenotype.getAnyAttribute("GT"));
						gBuilder.attribute("OLDPL", oldGenotype.getAnyAttribute("PL"));
						List<Allele> gAlleles = new ArrayList<Allele>();
						int genotype = v.getGenotypes()[sampleNo];
						if (genotype == 0) {
							gAlleles.add(alleles.get(0));
							gAlleles.add(alleles.get(0));
						} else if (genotype == 1) {
							gAlleles.add(alleles.get(0));
							gAlleles.add(alleles.get(1));
						} else {
							gAlleles.add(alleles.get(1));
							gAlleles.add(alleles.get(1));
						}
						gBuilder.alleles(gAlleles);
						int[] pl = new int[3];
						for (int i = 0; i < 3; i++) {
							v.getGenotypes()[sampleNo] = i;
							pl[i] = (int) (10.0 * v.getCost(contributions[sampleNo], sampleNo) / Math.log(10.0));
						}
						v.getGenotypes()[sampleNo] = genotype;
						int gq;
						if (genotype == 0) {
							pl[1] -= pl[0];
							pl[2] -= pl[0];
							pl[0] = 0;
							gq = Math.min(pl[1], pl[2]);
						} else if (genotype == 1) {
							pl[0] -= pl[1];
							pl[2] -= pl[1];
							pl[1] = 0;
							gq = Math.min(pl[0], pl[2]);
						} else {
							pl[0] -= pl[2];
							pl[1] -= pl[2];
							pl[2] = 0;
							gq = Math.min(pl[0], pl[1]);
						}
						gBuilder.PL(pl);
						gBuilder.GQ(gq);
						Genotype newGenotype = gBuilder.make();
						newGenotypes.add(newGenotype);
					} else {
						newGenotypes.add(oldGenotype);
					}
				}
				builder.genotypes(newGenotypes);
				writer.add(builder.make());
			} else {
				writer.add(context);
			}
		}
	}
}
